/*
 * @lc app=leetcode id=924 lang=rust
 *
 * [924] Minimize Malware Spread
 */

// @lc code=start
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();
        let mut colors = vec![-1; n];
        let mut c = 0;

        fn dfs(graph: &Vec<Vec<i32>>, colors: &mut Vec<i32>, i: usize, c: i32) {
            colors[i] = c;
            for j in 0..graph.len() {
                if graph[i][j] == 1 && colors[j] == -1 {
                    dfs(graph, colors, j, c);
                }
            }
        }
        for i in 0..n {
            if colors[i] == -1 {
                dfs(&graph, &mut colors, i, c as i32);
                c += 1;
            }
        }

        let mut size = vec![0; c];
        for &color in &colors {
            size[color as usize] += 1;
        }
        let mut color_count = vec![0; c];
        for &node in &initial {
            color_count[colors[node as usize] as usize] += 1;
        }
        let mut ans = i32::MAX;
        for &node in &initial {
            let c = colors[node as usize] as usize;

            if color_count[c] == 1 {
                if ans == i32::MAX {
                    ans = node;
                } else if size[c] > size[colors[ans as usize] as usize] {
                    ans = node;
                } else if size[c] == size[colors[ans as usize]  as usize] && node < ans {
                    ans = node;
                }
            }
        }
        if ans == i32::MAX {
            *initial.iter().min().unwrap()
        } else {
            ans
        }
    }
}
// @lc code=end
