/*
 * @lc app=leetcode id=924 lang=rust
 *
 * [924] Minimize Malware Spread
 */

// @lc code=start
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();
        let mut colors = vec![-1; n];
        let mut c = 0;

        fn dfs(graph: &Vec<Vec<i32>>, colors: &mut Vec<i32>, i: usize, c: i32) {
            colors[i] = c;
            for j in 0..graph.len() {
                if graph[i][j] == 1 && colors[j] == -1 {
                    dfs(graph, colors, j, c);
                }
            }
        }
        for i in 0..n {
            if colors[i] == -1 {
                dfs(&graph, &mut colors, i, c as i32);
                c += 1;
            }
        }

        let mut size = vec![0; c];
        for &color in &colors {
            size[color as usize] += 1;
        }
        let mut color_count = vec![0; c];
        for &node in &initial {
            color_count[colors[node as usize] as usize] += 1;
        }
        let mut ans = i32::MAX;
        for &node in &initial {
            let c = colors[node as usize] as usize;

            if color_count[c] == 1 {
                if ans == i32::MAX {
                    ans = node;
                } else if size[c] > size[colors[ans as usize] as usize] {
                    ans = node;
                } else if size[c] == size[colors[ans as usize]  as usize] && node < ans {
                    ans = node;
                }
            }
        }
        if ans == i32::MAX {
            *initial.iter().min().unwrap()
        } else {
            ans
        }
    }
}
// @lc code=end
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n=graph.len();
        let mut parent:Vec<usize>=(0..n).collect();
        let mut sz=vec![1;n];
        fn find(x:usize,parent:&mut Vec<usize>)->usize{
            let px=parent[x];
            if px!=x{
                parent[x]=find(px,parent);
            }
            parent[x]
        }
        let unite=|x:usize,y:usize,parent:&mut Vec<usize>,sz:&mut Vec<i32>|{
                let (px,py)=(find(x,parent),find(y,parent));
                if px!=py{
                    parent[px]=py;
                    sz[py]+=sz[px];
                }
        };
        for i in 0..n{
            for j in 0..n{
                if graph[i][j]==1{
                    unite(i,j,&mut parent,&mut sz);
                }
            }
        }
        let mut cnt=vec![0;n];
        for &node in &initial{
            cnt[find(node as usize,&mut parent)]+=1;
        }
        let mut ans=-1;
        let mut size=-1;
        for &i in &initial{
            let node=i as usize;
            let root=find(node,&mut parent);
            if cnt[root]!=1{
                continue
            }
            let root_size=sz[find(root,&mut parent)];
            if size<root_size{
                size=root_size;
                ans=i;
            }else if size==root_size && i<ans{
                ans=i;
            }
        }
        if ans==-1{
            initial.into_iter().min().unwrap()
        }else{
            ans
        }
    }
}