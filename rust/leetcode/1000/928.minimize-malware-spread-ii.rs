/*
 * @lc app=leetcode id=928 lang=rust
 *
 * [928] Minimize Malware Spread II
 */

// @lc code=start
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len() as i32;
        use std::collections::HashSet;
        let clean = (0..n)
            .collect::<HashSet<i32>>()
            .difference(&initial.iter().cloned().collect::<HashSet<i32>>()).cloned().collect();
        fn dfs(u: usize, graph: &Vec<Vec<i32>>, clean: &HashSet<i32>, seen: &mut HashSet<usize>) {
            for (v, &adj) in graph[u].iter().enumerate() {
                if adj > 0 && clean.contains(&(v as i32)) && !seen.contains(&v) {
                    seen.insert(v);
                    dfs(v, graph, clean, seen);
                }
            }
        }
        use std::collections::HashMap;
        let mut infected_by: HashMap<i32, Vec<i32>> =
            initial.iter().cloned().map(|x| (x, Vec::new())).collect();
        for &u in &initial {
            let mut seen = HashSet::new();
            dfs(u as usize, &graph, &clean, &mut seen);
            for &v in &seen {
                infected_by.entry(v as i32).or_insert(Vec::new()).push(u);
            }
        }
        let mut contribution = HashMap::new();
        for  neighbors in infected_by.values() {
            if neighbors.len() == 1 {
                *contribution.entry(neighbors[0]).or_insert(0) += 1;
            }
        }
        let mut best = vec![-1, *initial.iter().min().unwrap()];
        for (&u, &score) in &contribution {
            if score > best[0] || score == best[0] && u < best[1] {
                best = vec![score, u];
            }
        }
        best[1]
    }
}
// @lc code=end
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        use std::collections::{HashMap,HashSet};
        let n=graph.len();
        let initial:HashSet<i32>=initial.into_iter().collect();
        let clean:Vec<usize>=(0..n).filter_map(|x| if initial.contains(&(x as i32)){None}else{Some(x)}).collect();
        let mut parent:Vec<usize>=(0..n).collect();
        let mut size=vec![1;n];
        fn find(x:usize,parent:&mut Vec<usize>)->usize{
            let px=parent[x];
            if px!=x{
                parent[x]=find(px,parent);
            }
            parent[x]
        }
        let unite=|x:usize,y:usize,parent:&mut Vec<usize>,size:&mut Vec<i32 >|{
                let (px,py)=(find(x,parent),find(y,parent));
                if px!=py{
                    parent[px]=py;
                    size[py]+=size[px];
                }
        };
        for &u in &clean{
            for &v in &clean{
                if graph[u][v]==1{
                    unite(u,v,&mut parent,&mut size);
                }
            }
        }
        let mut count=HashMap::new();
        let mut node_to_compo=HashMap::new();
        for &u in &initial{
            let mut component=HashSet::new();
            for &v in &clean{
                if graph[u as usize][v]==1{
                    component.insert(find(v,&mut parent));
                }
            }
            for &c in &component{
                *count.entry(c).or_insert(0)+=1;
            }
            node_to_compo.insert(u,component);
        }
        let mut ans=n as i32;
        let mut best=-1;
        for (&u,component) in &node_to_compo{
            let mut score=0;
            for &c in component{
                if count[&c]==1{
                    score+=size[find(c,&mut parent)];
                }
            }
            if score>best||(score==best && u<ans){
                ans=u;
                best=score;
            }
        }
        ans
    }
}